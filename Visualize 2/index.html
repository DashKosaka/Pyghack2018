<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <title>Student Class Heatmap</title>
    <style>
        /* Always set the map height explicitly to define the size of the div
         * element that contains the map. */
        #map {
            height: 80%;
        }

        /* Optional: Makes the sample page fill the window. */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        .slidecontainer {
            width: 50%;
            padding: 2%;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 15px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #5cf958;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        /*Button group css*/
        .btn-group button {
            background-color: #4CAF50; /* Green background */
            border: #4CAF50; /* Green border */
            color: white; /* White text */
            padding: 10px 24px; /* Some padding */
            cursor: pointer; /* Pointer/hand icon */
            float: left; /* Float the buttons side by side */
            font-family: "Calibri Light", Times, serif;
            font-size: 20px;
        }

        .btn-group button:not(:last-child) {
            border-right: none; /* Prevent double borders */
        }

        /* Clear floats (clearfix hack) */
        .btn-group:after {
            content: "";
            clear: both;
            display: table;
        }

        /* Add a background color on hover */
        .btn-group button:hover {
            background-color: #3e8e41;
        }

        /*Text style*/
        p.serif {
            font-family: "Calibri Light", Times, serif;
        }

    </style>
</head>
<body>
<div id="map"></div>
<script>


    var citymap;
    var query;
    var drawn = false;
    var day_chosen;
    var time_chosen;
    var slider = document.getElementById("myRange");

    function update_day(day){
        day_chosen = day;
        console.log(day_chosen);
        initMap(city_map, day_chosen, time_chosen);
    }

    function update_time(time){
        time_chosen = time;
        console.log(time_chosen);
        initMap(city_map, day_chosen, time_chosen);
    }

    function loadFile(filename) {
        myPromise = asyncGetFile(filename);

        myPromise.then((retrievedText) => {
            citymap = JSON.parse(retrievedText);
            // for (var result in populationAtLocation(citymap, "M", 900)) {
            //     console.log(result);
            // }
            // console.log("File retrieved");
            // console.log(citymap);

        })
            .catch(
                (reason) => {
                    console.log('handle rejected promise (' + reason + ') here.')
                });

    }


    function asyncGetFile(url) {
        // console.log("Getting text file");
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("Get", url);
            xhr.onload = () => resolve(xhr.responseText);
            xhr.onerror = () => reject(xhr.statusText);
            xhr.send();
            // console.log("Made promise");
        });

    }

    function initMap(data, time, day) {
        if (typeof(citymap) == 'undefined' || typeof(data) == 'undefined' || typeof(day) == 'undefined'){
            return;
        }
        var cur_query = populationAtLocation(data, time, day);
        query = cur_query;

        // Create the map.

        var map = new google.maps.Map(document.getElementById('map'), {
            zoom: 17,
            center: {lat: 40.107472, lng: -88.227236},
            mapTypeId: 'terrain'
        });

//        console.log(cur_query[building]["center"]["lat"]);
        // Construct the circle for each value in citymap.
        // Note: We scale the area of the circle based on the population.
        for (var building in cur_query) {
            // console.log(city);
            // Add the circle for this city to the map.
//            console.log(building);
//            console.log(cur_query[building].population);
//            console.log(cur_query[building].center);
            var cityCircle = new google.maps.Circle({
                strokeColor: '#FF0000',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: '#FF0000',
                fillOpacity: 0.35,
                map: map,
                center: cur_query[building].center,
                radius: Math.sqrt(cur_query[building].population) * 3
            });
        }
        drawn = true;

    }

    function startup() {
        loadFile("map_data.json");
        tick();

    }

    function tick() {
        requestAnimFrame(tick);
        if (citymap && !drawn)
            initMap(citymap, "M", 900);

    }

    function populationAtLocation(data, day, time) {

        var populations = {}
        var curr_pop;
        var curr_location;
        for(var crn in data) {

            // Check if the day is the same
            // Check if time is after begin time
            // Check if time is before end time
            if(data[crn].Day.indexOf(day) > -1 && data[crn]["Start time"] <= time && time <= data[crn]["End time"]) {
                curr_pop = data[crn].Population;
                curr_location = data[crn].Location.lat.toString() + data[crn].Location.lng.toString();
//                curr_location = data[crn
                if(curr_location in populations)  {
                    populations[curr_location].population += curr_pop;
                } else {
                    populations[curr_location] = {}
                    populations[curr_location].population = curr_pop;
                    populations[curr_location].center = data[crn].Location;
                }
            }
        }
//        for (var building in populations) {
//            console.log(populations[building]);
//        }
        return populations
    }
</script>
<script src="webgl-utils.js"></script>
<script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDVnvwBcCllCfpVXnHh6OPiga3MiLcswGo&callback=startup">
</script>

<div class="btn-group" id="btn-group">
    <button onclick="update_day('Sun')">Sunday</button>
    <button onclick="update_day('M')">Monday</button>
    <button onclick="update_day('T')">Tuesday</button>
    <button onclick="update_day('W')">Wednesday</button>
    <button onclick="update_day('R')">Thursday</button>
    <button onclick="update_day('F')">Friday</button>
    <button onclick="update_day('Sat')">Saturday</button>
</div>

<div class="slidecontainer">
    <input type="range" min="0" max="1439" value="50" class="slider" id="myRange">
<p class="serif" id="demo"></p>
</div>


<script>
    var slider = document.getElementById("myRange");
    var output = document.getElementById("demo");
    output.innerHTML = convert_minutes_to_std_time(slider.value);

    function convert_minutes_to_std_time(time_num) {
        var meridian;
        if (time_num >= 720) {
            meridian = "PM";
        } else {
            meridian = "AM";
        }
        var converted_time_num = time_num%720
        var hours = Math.floor(converted_time_num / 60);
        if (hours == 0) { // <--- WTF IS THIS CODE
            hours = 12;
        }
        var minutes = ("0" + (converted_time_num % 60)).slice(-2);
        return "" + hours + ":" + minutes + meridian;
    }

    slider.oninput = function () {
        update_time(slider.value);
        output.innerHTML = convert_minutes_to_std_time(slider.value);
    }
</script>

</body>
</html>